# プログラミングコンテスト攻略のためのアルゴリズムとデータ構造
Date: 2021-05-28

<hr>

## アルゴリズムとは

### アルゴリズム
あることを達成するための手順  

### 計算量

## データ構造

### データ構造
データを効率的に扱うために、問題に応じてさまざまなデータ構造をとる。  

### 3つの要素

#### 集合
データの本体のこと  
(ex) 配列、構造体  

#### 規則
操作、管理、保持するための決まり事  
(ex) どのような順番でデータを取り出すか  

#### 操作
データの集合に対する操作  
(ex) 要素の追加、取り出し、要素数を調べる  

### 基本的なデータ構造

#### スタック

##### 必要な変数

- データを格納するための整数型1次元配列S  
Sには問題に応じて十分な記憶領域が必要  
ここでの紹介では、S[0]は常にからの状態にしている（なんで？）  
→ topが0の場合には、配列をからと見なすため？  

- トップ（スタックポインタ）を表す整数型変数top  
要素の最後が格納されている位置を示す。  
topの値は、配列のながさに等しくなる  

- スタックに要素を追加する関数push(x)  
topを一つ増やして、S[top]にxを代入する  

- スタックのトップから要素を取り出す関数pop(x)  
S[top]の値を返してtopを一つ減らす  
（ここの格納されていた値はどうなるのかな？）  

#### 配列によるスタックの実装

```
initialize()
	top = 0

isEmpty()
	return top == 0

isFull()
	return top >= MAX - 1

push(x)
	if isFull()
		エラー(オーバーフロー)
	top++
	S[top] = x

pop()
	if isEmpty()
		エラー(アンダーフロー)
	top--
	return S[top+1]
```

#### キュー

##### 必要な変数

- データを格納するための整数型1次元配列Q  
Qには問題に応じて十分な記憶領域が必要  

- 先頭ポインタである整数型変数head  
キューの先頭を指し示す変数  
dequeueによってheadで示されている要素が取り出される  
キューの先頭の要素が常に0ではないことに注意  

- 末尾ポインタである整数型変数tail  
最後の要素の一つ後ろを指し示す変数  
ここに新しい要素が追加される  
headとtail（tailは含まない）が指し示す場所がキューの中身  

- キューに要素xを追加する関数enqueue(x)
Q[tail]にxを代入し、tailを1つ増やす  

- キューの先頭から要素を取り出す関数dequeue()
Q[head]の値を返し、headを1つ増やす  

#### リングバッファ  
キューの中身がどんどん後ろにずれていって、オーバーフローすることになる  
head/tailが配列の領域を超えてしまった場合にはポインタを一つ増やしてポインタを0にリセットする  
具体的には、tailが上限を超えた場合に0にする  

#### 配列によるキューの実装

```
initialize()
	head = tail = 0
isEmpty()
	return head == tail

isFull()
	return head == (tail + 1) % MAX

enqueue(x)
	if isFull()
		エラー(オーバーフロー)
	Q[tail] = x
	if tail + 1 == MAX
		tail = 0
	else
		tail++

dequeue()
	if isEmpty()
		エラー(アンダーフロー)
	x = Q[head]
	if head + 1 == MAX
		head = 0
	else
		head++
	return x
```

<hr>

#### 連結リスト

##### 双方向連結リスト
各要素のことをノードとよぶ 

自分をさすkeyと次をさすnext、前をさすprevによって実装できる  

```c
struct Node {
	int key;
	Node *prev, *next;
};
```
