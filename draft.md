# push_swapの実装

## どうやって一番小さい手数を見つける？

最小かどうかを判定するのは非常に難しいので、push_swapが決める基準をクリアすればいい  

ピボットを決める（ランダムに3つ選んで中央値をとる）  


### メモ
大小に分けるときは、Aピポットよりも大きいのを残して、Bにピポット以下の物を持っていく  
→ 大きいのをAに持っていって、小さいのをBに残す  
4こ以上Bに残っていれば、再びピポっとを決めて、大きいものをAに持っていく  
3こになったらルールベースのソートをする？  
ソートしたらpushして、revlveする  
→ 後ろはソート済みにする？  

### 使用可能な操作
- sa: aの上のふたつをスワップする  
- sb: bの上のふたつをスワップする  
- ss: saとsbを同時に行う  
- pa: bの上をaの上に持ってくる  
- pb: aの上をbの上に持ってくる  
- ra: aを一つずらす（一番前が一番最後になる）  
- rb: bを一つずらす（一番前が一番最後になる）  
- rr: raとrbを同時に   
- rra: aを逆に1つずらす（一番最後が一番最初になる）  
- rrb: bを逆に1つずらす（一番最後が一番最初になる）  
- rrr: rraとrrbを一緒に行う  

## データ構造
- A と B で別々の双方向循環連結リストを作ればいい？  

## 実装の流れ
1. 指定された操作の関数を作る
2. ルールベースはこれで完成

### 関数
- sa: 

A: nil <=> 1 <=> 4 <=> 5 <=> nil  

prev / nextを6こずつ入れ替えればいい？  
中の値かえるのではだめ？  

B: 2 <=> 3 <=> 6  

- sb: 
- ss: 
- pa: 

A: nil <=> 1 <=> 4 <=> 5 <=> nil  
B: nil <=> 2 <=> 3 <=> 6 <=> nil  

挿入して、deleteすればいい  

- pb: 
- ra: 

A: nil <=> 1 <=> 4 <=> 5 <=> nil  

prev / nextを6こ入れ替える？  

A: nil <=> 4 <=> 5 <=> 1 <=> nil  

- rb: 
- rr: 
- rra: 

A: nil <=> 1 <=> 4 <=> 5 <=> nil  

prev / nextを6こ入れ替える？  

A: nil <=> 5 <=> 1 <=> 4 <=> nil  

- rrb: 
- rrr: 

## シミュレーション
  
ピボット:4  
A: 3 5 8 1 2 9 4 7 6  
B:   
  
sb  
A: 5 8 1 2 9 4 7 6  
B: 3  
  
None  
A: 5 8 1 2 9 4 7 6  
B: 3  
  
None  
A: 5 8 1 2 9 4 7 6  
B: 3  
  
ra  
A: 8 1 2 9 4 7 6 5  
B: 3  
  
ra  
A: 1 2 9 4 7 6 5 8  
B: 3  
  
pb  
A: 2 9 4 7 6 5 8  
B: 1 3  
  
pb  
A: 9 4 7 6 5 8  
B: 2 1 3  
  
None  
A: 9 4 7 6 5 8  
B: 2 1 3  
  
ra  
A: 4 7 6 5 8 9  
B: 2 1 3  
  
pb  
A: 7 6 5 8 9  
B: 4 2 1 3   
  
None  
A: 7 6 5 8 9  
B: 4 2 1 3   
  
None  
A: 7 6 5 8 9  
B: 4 2 1 3   
  
<hr>  
  
ピボット:2  
  
pa  
A: 4 7 6 5 8 9  
B: 2 1 3   
  
None  
A: 4 7 6 5 8 9  
B: 2 1 3   
  
None  
A: 4 7 6 5 8 9  
B: 2 1 3   
  
rrb  
A: 4 7 6 5 8 9  
B: 3 2 1   
  
pa  
A: 3 4 7 6 5 8 9  
B: 2 1   
  
<hr>  
  
ピボット：2  
  
rb  
A: 3 4 7 6 5 8 9  
B: 1 2   
  
pa  
A: 1 3 4 7 6 5 8 9  
B: 2   
  
ra  
A: 3 4 7 6 5 8 9 1  
B: 2   
  
pa  
A: 2 3 4 7 6 5 8 9 1  
B:   
  
ra  
A: 3 4 7 6 5 8 9 1 2  
B:    
  
<hr>  
  
3と4を持ってくる  
  
pb  
A: 4 7 6 5 8 9 1 2  
B: 3  
  
pb  
A: 7 6 5 8 9 1 2  
B: 4 3  
  
pa   
A: 3 7 6 5 8 9 1 2  
B: 4  
  
ra  
A: 7 6 5 8 9 1 2 3  
B: 4  
  
pa   
A: 4 7 6 5 8 9 1 2 3  
B:   
  
ra  
A: 7 6 5 8 9 1 2 3 4  
B:  
  
<hr>  
  
ピボット：8  
  
pb  
A: 6 5 8 9 1 2 3 4  
B: 7  
  
pb  
A: 5 8 9 1 2 3 4  
B: 6 7  
  
pb  
A: 8 9 1 2 3 4  
B: 5 6 7  
  
pb  
A: 9 1 2 3 4  
B: 8 5 6 7  
  
None  
A: 9 1 2 3 4  
B: 8 5 6 7  
<hr>  
  
ピポット：7  
  
pa  
a: 8 9 1 2 3 4  
b: 5 6 7  
    
None  
a: 8 9 1 2 3 4  
b: 5 6 7  
  
None  
a: 8 9 1 2 3 4  
b: 5 6 7  
  
None  
a: 8 9 1 2 3 4  
b: 5 6 7  
  
pa  
a: 5 8 9 1 2 3 4  
b: 6 7  
  
ra  
a: 8 9 1 2 3 4 5  
b: 6 7  
  
pa  
a: 6 8 9 1 2 3 4 5  
b: 7  
  
ra  
a: 8 9 1 2 3 4 5 6  
b: 7  
  
pa  
a: 7 6 8 9 1 2 3 4 5  
b:   
  
ra  
a: 8 9 1 2 3 4 5 6 7  
b:   
<hr>  
  
ピポット8    
  
pb   
a: 9 1 2 3 4 5 6 7  
b: 8   
  
pb   
a: 1 2 3 4 5 6 7  
b: 9 8   
  
rb  
a: 1 2 3 4 5 6 7  
b: 8 9  
  
pa  
a: 8 1 2 3 4 5 6 7  
b: 9  
  
ra  
a: 1 2 3 4 5 6 7 8  
b: 9  
  
pa  
a: 9 1 2 3 4 5 6 7 8  
b:   
  
ra  
a: 1 2 3 4 5 6 7 8 9  
b: 


<hr>


## 実装
- sa: aの上のふたつをスワップする  
→ tmpを使ってinisertで入れ替える感じ  

- sb: bの上のふたつをスワップする  
→ tmpを使ってinisertで入れ替える感じ  

- ss: saとsbを同時に行う  

- pa: bの上をaの上に持ってくる  
→ insertとdeleteでやる感じ  

- pb: aの上をbの上に持ってくる  

- ra: aを一つずらす（一番前が一番最後になる）  
→ addelem（ウシロニツイッカ）とdeleteを使う感じ  

- rb: bを一つずらす（一番前が一番最後になる）  
- rr: raとrbを同時に   
- rra: aを逆に1つずらす（一番最後が一番最初になる）  
- rrb: bを逆に1つずらす（一番最後が一番最初になる）  
- rrr: rraとrrbを一緒に行う  

<hr>

### deletenode

- [構造体のfree](http://oswald.hatenablog.com/entry/20081129/1228697674)  

#### 疑問点

- freeしたときに8kbではなく、12kbになってしまうのはなぜ？  
- 操作したものは、配列に入れておく？標準出力にすぐ出しちゃう？  

<hr>

### push
- popするときは、いちいちメモリを確保おしなおす必要はない  

### swap
nil <-> first <-> second <-> third

nil->next = second

first->prev = second
first->next = third

second->prev = nil
second->next = first

third->prev = first

### ルールベースのやつ
長さが6こ以下の時  
Aの一番小さいやつを一番上に持ってきて、Bにうつす  
これをAが3こになるまでやる  

#### 3こ以下のやつ  
sort_rule_based  

1こなら何もしない  
2こなら大小に応じてswap  
3コナラ以下のパターンにあてめる  

- 213  
sa  

- 321  
sa→ rra  

- 312  
ra  

- 132  
sa→ ra  

- 231  
rra  

<hr>

213 or 321 or 132 → sa  

312 → ra   

231 → rra  

<hr>


